<!DOCTYPE html>
<html>
  <head>
    <title>Rust & WebAssembly</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Bitter);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Bitter'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
        /* color: blue; */
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 1.9em; }
      .remark-slide-content h3 { font-size: 1.3em; }

      .remark-slide-number {
        position: inherit;
        opacity: unset;
      }

      .remark-slide-number .progress-bar-container {
        position: absolute;
        bottom: 0;
        height: 6px;
        display: block;
        left: 0;
        right: 0;
      }

      .remark-slide-number .progress-bar {
        height: 100%;
        background-color: #f92672;
      }

      .remark-slide-scaler {
        box-shadow: none; /* remove slide frame */
      }
      .remark-slide-container {
        background: black; /* match slide container color with slides */
      }

      .inverse {
        background: #3c2d9e;
        color: #f92672;
        text-shadow: 0 0 20px #111;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      .inverse a {
        color: #f3f3f3;
      }

      a {
        color: #f92672;
        text-decoration: solid;
      }
      .remark-inline-code {
        line-height: 1.3em;
        background-color: #f3f3f3;
        padding-top: 1px;
        padding-left: 3px;
        padding-right: 3px;
        /* padding: 2px; */
        padding-bottom: 3px;
        color: #f92672;
      }

      #meet-ferris {
        position: absolute;
        right: -165px;
        top: 10px;
      }

      #ferris-banner {
        left: 0;
        right: 0;
        top: 0;
        position:absolute;
        background: white;
        width: 100%;
      }

      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono';
        border-radius: 4px;
      }
      .remark-code-line-highlighted {
        background-color: rgb(94, 51, 67);
      }

      /* Code comment style */
      .hljs-atom-one-dark .hljs-comment, .hljs-atom-one-dark .hljs-quote {
        color: #6e7592;
      }

      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 25%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle, inverse

<div id="ferris-banner"><br><img src="img/ferris.gif" alt="Ferris" width="50%"></div>

<div id="meet-ferris"><img src="img/meet_ferris.svg" width="35%"></div>

<br>

# Rust & WebAssembly

_an introduction to developing modern systems_

by Nikolai Vazquez ([@nvzqz](https://github.com/nvzqz))

follow along: [nikolaivazquez.com/rust-workshop](https://nikolaivazquez.com/rust-workshop)

---

.left-column[
## What is Rust?
]

.right-column[
<div align="center">
  <img style="margin:-40px" src="img/rust-logo.svg", width="60%">
</div>

A systems programming language that:

- Runs blazingly fast without compromise

- Prevents invalid memory access (segfaults)

- Guarantees thread safety (via `Send` and `Sync` traits)

- Is open source ([github.com/rust-lang/rust][rust])
and actively developed by Mozilla and the community

Read more at [rust-lang.org](https://www.rust-lang.org/)...
]

---

.left-column[
## What is Rust?
## What is WASM?

<img src="https://webassembly.org/images/firefox.svg" width="42px">
<img src="https://webassembly.org/images/chrome.svg" width="42px">
<img src="https://webassembly.org/images/safari_96x96.png" width="42px">
<img src="https://webassembly.org/images/edge.svg" width="42px">

Supported on 4 major browsers
]

.right-column[
<div align="center">
  <img style="margin: 41px" src="https://webassembly.org/css/webassembly.svg", width="60%">
</div>

A new language for the web ([announced in 2015](https://webassembly.org/roadmap/#past-milestones)) that:

- Runs sandboxed alongside JavaScript, augmenting it

- Gets compiled from other languages like C, C++, Rust, and eventually others
that are garbage-collected

- Is similar to `.class` files for the Java Virtual Machine

- Offers maximized reliable performance by design

Read more at [webassembly.org](https://webassembly.org)...
]

---

.left-column[
## What is Rust?
## What is WASM?
## Rust Features
]

.right-column[
- Abstractions with zero runtime cost

- Move semantics (copying is often opt-in)

- Guaranteed memory safety

- Threads without data races

- Trait-based generics

- Pattern matching

- Powerful metaprogramming (macros or build script)

- Type inference (knows `x` in `let x = 20;` is an `i32`)

- Very minimal runtime

- Can efficiently call C _and_ be exposed as C

- State-of-the-art package manager (Cargo)
]

---

.left-column[
## What is Rust?
## What is WASM?
## Rust Features
## Who Uses Rust
]

.right-column[
These companies are currently using Rust in production:

- Mozilla

- Dropbox

- Atlassian

- Postmates

- Coursera

- Amazon Web Services

- NPM (Node.js Package Manger)

- Google

- [Others...](https://www.rust-lang.org/en-US/friends.html)
]

???

| Company   | &nbsp | How? |
| :-------- | ----- | :--- |
| Mozilla   | | Integrated in Firefox and other projects |
| Dropbox   | | Optimizing cloud file-storage |
| Atlassian | | Analyzing petabytes of source code |
| Postmates | | Used by Infrastructure team to write system daemons |
| Coursera  | | Programming Assignments in secured Docker containers |
| AWS       | | AWS Lambda runtime |
| NPM       | | Replacing C and rewriting performance-critical bottlenecks in the registry service architecture |
| Google    | | Components of Fuchsia (experimental OS) |

---

.left-column[
## What is Rust?
## What is WASM?
## Rust Features
## Who Uses Rust
## Rust Setup
]

.right-column[
- The Rust compiler and toolchain (including Cargo) can be installed by
following the instructions at [rustup.rs][rustup]:

  Run the following on *nix (Unix, Linux, macOS):

  ```sh
  curl https://sh.rustup.rs -sSf | sh
  ```

  Otherwise if on Windows 64-bit, download and run
  [`rustup‚Äëinit.exe`](https://win.rustup.rs/x86_64).

  For just learning Rust, it is sufficient to follow along using
  [play.rust-lang.org][play]. See the next slide for setting up WebAssembly.

- Once that‚Äôs installed, `cargo-generate` should be installed:

  ```sh
  cargo install cargo-generate
  ```
]

---

.left-column[
## What is Rust?
## What is WASM?
## Rust Features
## Who Uses Rust
## Rust Setup
## WASM Setup
]

.right-column[
- [wasm-pack](https://rustwasm.github.io/wasm-pack/installer/)

  Run the following on *nix (Unix, Linux, macOS):

  ```sh
  curl \
  https://rustwasm.github.io/wasm-pack/installer/init.sh \
  -sSf | sh
  ```

  Otherwise if on Windows 64-bit, download and run [`wasm-pack-init.exe`](https://github.com/rustwasm/wasm-pack/releases/download/v0.5.1/wasm-pack-init.exe).

- [npm](https://www.npmjs.com/get-npm) or if already installed, make sure it is up to date:

  ```sh
  npm install npm@latest -g
  ```
]

---

class: center, middle, inverse

# Comparing Rust

_safety first, buckle up_

---

class: center, middle

# Comparing Rust

<img src="img/perf_vs_mem_safety.png", width="80%">

---

class: center, middle

# Comparing Rust

<img src="img/perf_vs_type_safety.png", width="80%">

---

<h1 align="center">Comparing Rust</h1>

.left-column[
## ...with Python
]

.right-column[
```python
# Python
def main():
    for count in range(0, 3):
        print("{}. Hello World!".format(count))
```

```rust
// Rust
fn main() {
    for count in 0..3 {
        println!("{}. Hello World!", count);
    }
}
```

The `!` in Rust signifies that `println!()` is a macro which, unlike functions,
takes a variable number of arguments.

In Python, if `count` is not provided, the code crashes at runtime. In Rust, the
code fails to compile if the argument for `{}` (`Display` formatter) is missing.
]

---

<h1 align="center">Comparing Rust</h1>

.left-column[
## ...with Python
## ...with Swift
]

.right-column[
```swift
// Swift
enum Resource<T> {
    case busy
    case ready(T)
    case unavailable
}

let res = Resource.ready(42)
```

```rust
// Rust
enum Resource<T> {
    Busy,
    Ready(T),
    Unavailable,
}

let res = Resource::Ready(42);
```

Enums are sum types, where a variant may store a value. Here `res` can either be
busy, ready, or unavailable, but never a combination.
]

---

<h1 align="center">Comparing Rust</h1>

.left-column[
## ...with Python
## ...with Swift
## ...with C++
]

.right-column[
```cpp
// C++
int &push_answer(std::vector<int> &buf) {
    buf.push_back(42);
    return buf.back(); // undefined if `buf` is empty
}
```

```rust
// Rust
fn push_answer(buf: &mut Vec<i32>) -> &mut i32 {
    buf.push(42);
    buf.last_mut().unwrap() // crash if `buf` is empty
}
```

In C++, if `buf` is resized after calling `push_answer()`, the returned pointer
becomes invalid unbeknownst to you. Rust prevents accessing the returned
`&mut i32` if `buf` is accessed within the same scope, since both point to the
same mutable data (enforced mutual exclusion).
]

---

<h1 align="center">Comparing Rust</h1>

.left-column[
## ...with Python
## ...with Swift
## ...with C++

See [playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2015&gist=cfe7103cb031118e5478bc779505a288)

**Note:** Requires nightly Rust for [non-lexical lifetimes](https://github.com/rust-lang/rfcs/blob/master/text/2094-nll.md)
]

.right-column[
```rust
#![feature(nll)] // Enable "non-lexical lifetimes" (nightly)

// Note: `{:?}` denotes use of `Debug` formatting
fn main() {
    let mut x = vec![1, 2, 3];   // `x` is growable
    println!("{:?}", x);         // "[1, 2, 3]"

    let y = push_answer(&mut x); // `y` is ref to 42 in `x`
    println!("{:?}", y);         // "42"

    // Legal because `y` is not used again
    println!("{:?}", x);         // "[1, 2, 3, 42]"

    x.clear();                   // empty contents of `x`
    println!("{:?}", x);         // "[]"

    // Illegal because 42 was removed, which `y` refers to
    // println!("{:?}", y);
}
```
]

---

class: center, middle, inverse

# Types

_a typical language topic_

---

# Primitives

Rust is strictly statically typed, but the compiler is flexible and can infer
what type an expression is based on context. All primitives listed can be
inferred from just literals.


| Category                                    | &nbsp | Types |
| :------------------------------------------ | ----- | :--- |
| Signed integers                             | | `i8`, `i16`, `i32`, `i64`, `i128`, `isize` |
| Unsigned integers                           | | `u8`, `u16`, `u32`, `u64`, `u128`, `usize` |
| Floating point numbers                      | | `f32`, `f64` |
| Unicode scalar: `'a'`, `'Œ±'`, `'‚àû'`         | | `char` |
| Boolean: either `true` or `false`           | | `bool` |
| Nullable value: `Some(T)` or `None`         | | `Option<T>` |
| Either value (`Ok(T)`) or error (`Err(E)`)  | | `Result<T, E>` |
| Arrays (strictly homogenous): `[1, 2, 3]`   | | `[T; N]` (`[i32; 3]`) |
| Tuples (heterogenous): `(1, true)`          | | `()`, `(T,)`, `(T, U)`, `(T, U, V)`, ... |

**Note:** `(T)` is equivalent to just `T` whereas `(T,)` is a single-element
tuple.

---

# Reference Types

.pull-left[
## Rust-style (safe)

- `&T` (immutable, shared borrow)

- `&mut T` (mutable, mutex borrow)

- `Box<T>` (mutable, owned)

Non-nullable and statically checked at compile-time to ensure correct usage.

All implement the `Send` marker trait, making them safe to pass into threads
with move semantics, or stored in `static` values.
]

.pull-right[
## C-style (raw, unchecked)

- `*const T`

- `*mut T`

<br>

Raw, nullable pointers that you can find in C as `const T*` and `T*`, but can
have unsized types (`*const str`).

Do not implement `Send` and _can't_ be sent between threads nor stored in
`static` values.
]

---

class: center, middle, inverse

# Arrays & Friends

_an overview of contiguous data storage_

---

.left-column[
## Array Types
]

.right-column[
## `[T; N]`

- Can be allocated on the stack (default) or heap via `Box`

- Fixed compile-time size

```rust
let fib = [0, 1, 1, 2, 3, 5, 8];
let rep = [42; 100]; // 42 repeated 100 times
```

## `Vec<T>`

- Heap allocated and growable

- Equivalent to `ArrayList` (Java) or `std::vector` (C++)

```rust
let vec = vec![1, 2, 3, 4, 5]; // created with macro
let rep = vec![20; vec.len()]; // 20 repeated 5 times
```
]

---

.left-column[
## Array Types
## Slices
]

.right-column[
## `[T]`

```rust
fn byte_me(slice: &[u8]) { /* ... */ }

let bytes: Vec<u8> = get_bytes();
byte_me(&bytes);

byte_me(&[0xCA, 0xFE, 0xBA, 0xBE]);
```

Slices allow for getting a view into an array or vector.

This is such a common operation, that the conversion from `&Vec<T>` or `&[T; N]`
to `&[T]` is automatic.

```rust
fn shuffle(bytes: &mut [u8]) { /* ... */ }

let mut bytes = vec![1, 2, 3, 4]; // `u8` element inferred
shuffle(&mut bytes);
```

**Tip:** Unless growing or shrinking the buffer itself, use `&mut [T]` over
`&mut Vec<T>` for more flexible inputs.
]

---

.left-column[
## Array Types
## Slices
## Conversions
]

.right-column[
## From `Vec<T>` to `Box<[T]>`

```rust
let fib = vec![0, 1, 1, 2, 3, 5, 8];
let fib: Box<[i32]> = fib.to_boxed_slice();
```

Here we've converted `fib` from a resizable heap-allocated buffer of `i32` to a
fixed-size heap-allocated slice. The conversion just resizes the same allocation
such that `fib.capacity() == fib.len()`.

Because `Vec<T>` implements the `Into<Box<[T]>>` trait, we can replace the
`.to_boxed_slice()` call with just `.into()`:

```rust
let bocks: Box<[&str]> = vec!["hello", "world"].into();
```
]

---

.left-column[
## Array Types
## Slices
## Conversions

See [playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2015&gist=363c95d83df87f6249cddd8016090eb6)
]

.right-column[
## From `&[T]` to `&[T; N]` (or `&mut`/`Box`)

Conversions with the `From` and `Into` traits always succeed. However there's
also `TryFrom` and `TryInto` which may return errors if converting fails:

```rust
#![feature(try_from)] // requires nightly Rust

use std::convert::TryInto;

fn main() {
    // We can reference an array literal
    let slice: &[i32] = &[1, 2, 3];

    // Unwraps the result, which will `panic!()` on error
    let array: &[i32; 3] = slice.try_into().unwrap();

    println!("Got array of 3 elements: {:?}", array);
}
```

A `&[i32]` carries size with the address whereas `&[i32; 3]` is just the
address since the size is known at compile time.

**Fun fact:** I added these to the standard library myself! üòÅ
]

---

.left-column[
## Array Types
## Slices
## Conversions
## Indexing
]

.right-column[
## Bounds-Checking and Panicking

See generated assembly @ [godbolt.org/z/J0K0mP](https://godbolt.org/z/J0K0mP)

```rust
// Can be cast to integer type from base 0 via `as`
enum Index {
    Zero,
    One,
    Two,
}

type Array = [i32; 3]; // type alias

fn party_crashing_index(a: &Array, i: usize) -> &i32 {
    // Crash/panic if `i >= a.len()`
*   &a[i]
}

fn sober_index(a: &Array, i: Index) -> &i32 {
    // Never crash/panic because `i < a.len()` always
*   party_crashing_index(a, i as usize)
}
```
]

---

.left-column[
## Array Types
## Slices
## Conversions
## Indexing
]

.right-column[
## Looking Under the Hood

See generated assembly @ [godbolt.org/z/J0K0mP](https://godbolt.org/z/J0K0mP)

```asm
party_crashing_index:
        push    rax
        cmp     rsi, 2  ; compare `i` to `x.len()` (2)
        ja      .LBB0_2 ; jump to panic if `i > x.len()`
*       lea     rax, [rdi + 4*rsi]
        pop     rcx
        ret
.LBB0_2: ; code responsible for crashing/panicking
        lea     rdi, [rip + .Lpanic_bounds_check_loc.1]
        mov     edx, 3
*       call    core::panicking::panic_bounds_check@PLT
        ud2

sober_index: ; call to `party_crashing_index` inlined
        movzx   eax, sil
*       lea     rax, [rdi + 4*rax] ; no bounds check
        ret
```
]

---

.left-column[
## Array Types
## Slices
## Conversions
## Indexing

<img style="margin-top:-30px" src="img/marvin_pointing.jpg", width="90%">
]

.right-column[
## Don't `panic!()`

If you don't want to risk calls to `panic!()`, there's ways of avoiding it
altogether:

```rust
fn sane_indexing(a: &[i32], i: usize) {
    // `.get()` returns `Option<&i32>`
    if let Some(x) = a.get(i) {
        println!("x safely equals {}", x);
    } else {
        assert!(i >= a.len());
    }
}
```

If you're a C aficionado where segfaults are your seatbelt, because the
operating system _totally_ has your back, you can skip bounds checks with
`unsafe`:

```rust
fn cray_indexing(a: &[i32], i: usize) {
    // `.get_unchecked()` returns `&i32`
    let x = unsafe { a.get_unchecked(i) };
    println!("Gotta go fast!! x = {}", x);
}
```
]

---

class: center, middle, inverse

# Strings

_programming: where ‚Äústrings‚Äù & ‚Äúthreads‚Äù<br>
have **nothing** to do with each other_

**Warning:** they're complicated üòÖ

---

.left-column[
## String Types
]

.right-column[
## `str`

```rust
let s: &str = "I will never change";
```

- Called a "string slice", where `&str` is a view into memory stored statically
or on the stack/heap

- Dynamic size; requires a "fat" pointer: address & size

- Can be converted to `String` with allocation cost

## `String`

```rust
let s: String = "I can change".into();
```

- Allocated on the heap

- Growable buffer

- Can be converted to `&str` at no runtime cost
]

---

.left-column[
## String Types
]

.right-column[
The `String` type can be converted seamlessly to `&str`:

```rust
fn gimme(string: &str) { /* ... */ }

let owned: String = "You own me".into();
let slice: &str   = "I am a reference";

gimme(&owned); // Requires passing `owned` as reference
gimme(slice);  // `slice` is already a reference
```

Rust does this conversion automatically because it has zero computational cost.

The same applies to converting `&mut String` to `&mut str`, like with converting
`&mut Vec<T>` to `&mut [T]`.
]

---

.left-column[
## String Types
]

.right-column[
The `String` type can _also_ be converted to `Box<str>`:

```rust
let owned: String = "You own me".into();
let other: Box<str> = owned.into_boxed_str(); // or `.into()`

gimme(&other);

// Illegal because `owned`'s contents have been
// moved to `other`; more on this later!
// gimme(&owned);
```

`Box<str>` is also heap allocated. But unlike `String`, it is fixed in size.

This conversion takes `owned` and shrinks the string's capacity to its length,
and then rebinds it to `other`.
]

---

.left-column[
## String Types
## Unicode
]

.right-column[
All strings in Rust are encoded as UTF-8.

```rust
let english = "The same thing?";
let spanish = "¬øLa misma cosa?";

assert_eq!(english.len(), 15);
assert_eq!(spanish.len(), 16);
```

These strings are of length **15** and **16**, which might surprise many of you.
English characters are ASCII and use one byte but other languages may use more.

```rust
assert_eq!("¬ø".as_bytes(), [194, 191]);
```

If we can't trust characters to be one byte, what do we do?
]

---

.left-column[
## String Types
## Unicode
]

.right-column[
**Solution:** iterators!

```rust
let spanish = "¬øLa misma cosa?";
let mut buf = vec![];

for ch in spanish.chars() {
    buf.push(ch);
}

assert_eq!(buf, ['¬ø', 'L', 'a', ' ', 'm', 'i', 's', 'm', 'a', ' ', 'c', 'o', 's', 'a', '?']);
```

The `.chars()` iterator will provide a `char`, which can encode a Unicode code
point.

**Warning:** the `char` type in Rust **is not** like `char` in C:

- C `char` is 1 byte

- Rust `char` is 4 bytes
]

---

.left-column[
## String Types
## Unicode
]

.right-column[
We could also have initialized `buf` without mutating it:

```rust
let buf: Vec<char> = spanish.chars().collect();
```

And if we wanted to get a `String` from `buf`, that's also straightforward:

```rust
let string: String = buf.into_iter().collect();
```

The `.into_iter()` method returns a type that implements the
`Iterator<Item = char>` trait, and any type that implements that can be
`.collect()`-ed into a `String`.
]

---

class: center, middle, inverse

# Rust‚Äôs Ownership Model

_the fun stuff_

---

.left-column[
## Ownership
]

.right-column[
```rust
let mut v: Vec<char> = vec!['a', 'b', 'c'];
let x = v;

v.extend_from_slice(&['x', 'y', 'z']);

println!("{:?}", v);
println!("{:?}", x);
```

1. Here we allocate a vector of 3 `char`s and assign it to `v`.

2. We're going to be mutating `v`, so let's keep the original somewhere. We'll
assign `v` to `x`.

3. Now let's go ahead and print out our original vector `v`.

    **Note:** `{:?}` denotes formatting with the `Debug` trait.

    When we run this, it's expected to print out:

    ```rust
    ['a', 'b', 'c', 'x', 'y', 'z']
    ['a', 'b', 'c']
    ```

4. Let's go compile our code!
]

---

.left-column[
## Ownership
]

.right-column[
```rust
let mut v: Vec<char> = vec!['a', 'b', 'c'];
*let x = v;

v.extend_from_slice(&['x', 'y', 'z']);

println!("{:?}", v);
println!("{:?}", x);
```

Uh oh...

```
let x = v;
    - value moved here

v.extend_from_slice(&['x', 'y', 'z']);
^ value used here after move

println!("{:?}", v);
                 ^ value used here after move

note: move occurs because `v` has type `std::vec::Vec<char>`,
which does not implement the `Copy` trait
```

Ugh... hwat?

Let's look at something similar in C++.
]

---

.left-column[
## Ownership
]

.right-column[
```cpp
using namespace std;

void print_vec(vector<int> const& vec) {
    for (auto const& c : vec)
        cout << c << ' ';
    cout << endl;
}

vector<int> v = { 1, 2, 3 };
*auto x = v; // copy `v`

v.push_back(20);

print_vec(v);
print_vec(x);
```

This outputs:

```rust
1 2 3 20
1 2 3
```

When we bind the value of `v` to `x`, it copies the vector.

We can perform the same copy in Rust, but it needs to be done explicitly.
]

---

.left-column[
## Ownership
]

.right-column[
```rust
let mut v: Vec<char> = vec!['a', 'b', 'c'];
*let x = v.clone(); // Make a copy

v.extend_from_slice(&['x', 'y', 'z']);

println!("{:?}", v);
println!("{:?}", x);
```
]

Let's compile this now...

# ü§û

---

.left-column[
## Ownership
]

.right-column[
```rust
let mut v: Vec<char> = vec!['a', 'b', 'c'];
let x = v.clone(); // Make a copy

v.extend_from_slice(&['x', 'y', 'z']);

println!("{:?}", v);
println!("{:?}", x);
```

Surprise! It compiles correctly and outputs:

```rust
['a', 'b', 'c', 'x', 'y', 'z']
['a', 'b', 'c']
```

Probably annoying, right?
]

---

.left-column[
## Ownership
## Borrowing

{\\__/}<br>
( ‚Ä¢ - ‚Ä¢)<br>
`üì¶`< \\

{\\__/}<br>
( ‚Ä¢ . ‚Ä¢)<br>
/ > `&'aüì¶`
]

.right-column[
Whenever we see a reference annotation like `'a`, it denotes a "lifetime":

```rust
fn bytes<'a>(input: &'a [u8], max: usize) -> &'a [u8] {
    match input.get(..max) {

        // return all bytes up to `max`
        Some(slice) => slice,

        // `max` out of bounds; return everything
        None => input,
    }
}
```

Here the `'a` lifetime is tied to `input` and we're telling Rust that the returned
slice lives as long as the data that `input` points to.
]
---

.left-column[
## Ownership
## Borrowing

{\\__/}<br>
( ‚Ä¢ - ‚Ä¢)<br>
`üì¶`< \\

{\\__/}<br>
( ‚Ä¢ . ‚Ä¢)<br>
/ > `&'aüì¶`
]

.right-column[
We can omit the lifetime if the output doesn't contain a reference or the output
lifetime is unambiguous:

```rust
fn bytes(input: &[u8], max: usize) -> &[u8] {
    // ...
}
```

But there are cases where it's necessary! If a function takes two references, we
want to be explicit about which one's lifetime the output is bound to:

```rust
fn get_first<'a, T>(a: &'a T, b: &T) -> &'a T {
    a
}
```
]
---

class: center, middle, inverse

# Custom Types

_‚Äúif you build it, he will come‚Äù_
<br>
\- Field of Dreams (1989)

---

.left-column[
## Structs

Also known as "product types"

See [playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2015&gist=865ebf043aa52af4df7dd51e60583c68)
]

.right-column[
Structs in Rust are exactly the same as those in C, only fields are private (to
everything outside the current module) by default.

They may also contain references with a given lifetime:

```rust
#![allow(dead_code, unused_variables)]

struct Data<'a> {
    value: u32,
    other: &'static str,
    bytes: &'a [u8],
}

// The returned value must live as long as `bytes`'s data
fn data<'a>(bytes: &'a [u8]) -> Data<'a> {
    let stack_bytes = [1, 2, 3];
    let message = "statics outlive all";

    Data {
        value: 20,
        other: message,
        bytes//: &stack_bytes // illegal; uncomment for why
    }
}

fn main() {
    // Input lifetime is extended to that of `d`
    let d = data(&[4, 5, 6]);
}
```
]

---

.left-column[
## Structs
## Enums

Also known as "sum types"
]

.right-column[
We can define some of Rust's primitives as enums:

```rust
enum bool {
    true,
    false,
}

enum Option<T>{
    Some(T),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Enums can also be defined in some funky ways:

```rust
enum Value<'a> {
    Pair {                // struct variant
        cond: bool,
        s: &'a str,
    },
    Bytes(&'a [u8], i32), // tuple variant
    Nothing,              // empty variant
}
```
]

---

.left-column[
## Structs
## Enums

Also known as "sum types"
]

.right-column[
[JSON](http://json.org)‚Äîthe standard notation for data on the web‚Äîcan be easily
represented within Rust's type system as an `enum`.

```rust
use std::collections::HashMap;

*#[derive(PartialEq)] // generates `==` code
enum Json {
    Object(HashMap<String, Json>),
    Array(Vec<Json>),
    String(String),
    Number(f64),
    Bool(bool),
    Null,
}

let json = Json::Num(20.0);

match &json { // pattern match by reference
    Json::Object(ref obj) => {
        let x: &HashMap<String, Json> = obj;
*       assert!(x == obj);
    },
    Json::Array(ref vec) => {
        let x: &Vec<Json> = vec;
*       assert!(x == vec);
    },
    _ => {
        // Must handle all other cases
    },
}
```
]

---

.left-column[
## Structs
## Enums
## Traits

Analogous to Java "interfaces" or Swift "protocols"
]

.right-column[
Traits are a contract that types uphold and are most used in generic contexts.
Here we define a `Square` trait that we implement for all types that implement
[`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html)
and [`Mul`](https://doc.rust-lang.org/std/ops/trait.Mul.html):

```rust
use std::ops::Mul;

trait Square {
    type Output;

    fn square(self) -> Self::Output;
}

impl<T: Mul + Copy> Square for T {
    // Some type that results from squaring
    type Output = <T as Mul>::Output;

    fn square(self) -> Self::Output {
        self * self // `Copy` needed to duplicate `self`
    }
}

fn square_square<T: Square<Output = T>>(x: T) -> T {
    x.square().square()
}

fn main() {
    // Works for `u16` and `u64`
    assert_eq!(square_square(4u16), 256);
    assert_eq!(square_square(5u64), 625);
}
```
]

---

.left-column[
## Structs
## Enums
## Traits

Analogous to Java "interfaces" or Swift "protocols"
]

.right-column[
Rust's thread safety is partially a result of two traits:

- [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html):
Automatically implemented for types that can be transferred across thread
boundaries‚Äîall members implement `Send`.

  ```rust
  pub unsafe auto trait Send { }
  ```

- [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html):
Automatically implemented on types for which it is safe to share references
between threads‚Äîall members implement `Sync`.

  ```rust
  pub unsafe auto trait Send { }
  ```

The `unsafe` keyword here means we must be careful about which types implement
these traits.

```rust
// Raw pointers can't be sent/shared between threads safely
struct Ptr(*const i32);

unsafe impl Send for Ptr { }
unsafe impl Sync for Ptr { }
```
]

---

class: center, middle, inverse

# Control Flow

_‚Äògoto‚Äô is sooo 1980‚Äôs_

---

.left-column[
## Conditions
]

.right-column[
In Rust, `if` statements can simply work on booleans:

```rust
let x: bool = // ...

if x {
    println!("Booyeah!");
} else {
    println!("Welp...");
}
```

Ternary operators don't exist in Rust like they do in C:

```c
int y = x ? 20 : 32;
```

Instead, `if` can be treated as an expression if _all_ branches end with an
expression.

```rust
let y = if x { 20 } else { 32 };
```
]

---

.left-column[
## Conditions
## Pattern Matching
]

.right-column[
Values can be matched against, usually in the context of enums:

```rust
let x: Option<i32> = // ...

if let Some(x) = x {
    println!("x = {}", x);
}
```

With `match`, we can do neat things such as:

- Treating it as an expression
- Having conditions for certain branches
- Ensuring branching is exhaustive

```rust
let x: Result<i32, Error> = Ok(20);

let y = match x {
    Ok(x) if (x % 2 == 0) => x * 7, // `x` is even
    Ok(x)                 => x * 4, // `x` is odd
    Err(e)                => panic!("Error: {}", e),
};

assert_eq!(y, 140);
```

Think of it like a `switch` statement with superpowers!
]

---

.left-column[
## Conditions
## Pattern Matching
## Loops
]

.right-column[
If you want, you can loop (almost) forever:

```rust
loop {
    // run until heat death of the universe
}
```

Because Rust _loves_ expressions, you can treat a `loop` as one by `break`-ing
out with a value:

```rust
use std::time::{Duration, Instant};

let start = Instant::now();
let wait = Duration::from_secs(1);

// Poor man's timer
let x = loop {
    if start.elapsed() >= wait {
        break 30;
    }
};

assert_eq!(x, 30);
```
]

---

.left-column[
## Conditions
## Pattern Matching
## Loops
## Returning
]

.right-column[
You may have been surprised by the lack of `return` statements in functions so
far. Returning a value is implicit if it's the last expression in a function.

However, Rust actually does have a `return` keyword:

```rust
fn get_value() -> i32 {
    mut let x: i32 = // ...

    loop {
        do_something(&mut x);

        if x % 2 == 0 {
            return x;
        } else if x % 3 == 0 {
            return x * 2;
        }
    }
}
```
]

---

class: center, middle, inverse

# Let‚Äôs Get Func-y

_a fun time_

---

.left-column[
## [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html) trait

See [playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2015&gist=42aaf44a61ef3340b4ec86e20d758ac9)
]

.right-column[
Used for functions or closures that can be called repeatedly and have no mutable
state:

```rust
fn lots_of_fun<T, F>(x: T, fun: F) -> T
    where F: Fn(T) -> T
{
    fun(fun(fun(x)))
}

let value = lots_of_fun(24, |x| x / 2);
assert_eq!(value, 3);
```
]

---

.left-column[
## [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html) trait
## [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html) trait

See [playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2015&gist=1ff853d1ec3b14f3aa227fb20a1d9797)
]

.right-column[
Used for functions or closures that can be called repeatedly and have mutable
state:

```rust
let mut x = 0;

// Closure that implements `FnMut` by mutating `x`
let mut plus_plus = || -> i32 {
    x += 1;
    x
};

for _ in 0..10 {
    print!("{} ", plus_plus());
}
```

This outputs:

```rust
1 2 3 4 5 6 7 8 9 10
```
]

---

.left-column[
## [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html) trait
## [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html) trait
## [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) trait

See [playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2015&gist=31054cae8c0bd9dca58be4931af2178e)
]

.right-column[
Used for functions or closures that can only be called once and mmay have
mutable state.

We can return an anonymous `FnOnce` function:

```rust
fn forward<F>(f: F) -> impl FnOnce(i32) -> Option<i32>
    where F: FnOnce(i32) -> i32
{
    |x| {
        let value = f(x);
        if value % 2 == 0 {
            Some(value)
        } else {
            None
        }
    }
}

let f = forward(|x| x * 3);

assert_eq!(f(2), Some(6));

// Illegal: Can't reuse `f`
// assert_eq!(f(3), None);
```

This ties back to Rust's ownership rules because `FnOnce` can only be called by
value, not by reference.
]

---

class: center, middle, inverse

# Parallelism

_let‚Äôs make full use of that expensive CPU_

---

.left-column[
## Multithreading

See [playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2015&gist=ab111702bc2738316f038b86fff0f33b)
]

.right-column[
The standard library lets us easily spawn new execution paths for other CPU
cores to process:

```rust
use std::thread;

fn main() {
    let mut handles = vec![];

    for i in 0..4 {
        let name: String = format!("Thread {}", i);

        handles.push(thread::spawn(move || {
            let id = thread::current().id();
            println!("{} = {:?}", name, id);
        }));
    }

    println!("Main thread = {:?}", thread::current().id());

    for handle in handles {
        // Wait for spawned child threads to finish
        handle.join().unwrap();
    }
}
```

We `move` each `name` instance into the child closure, making the child scope
responsible for deallocating it.
]

---

.left-column[
## Multithreading
]

.right-column[
If we don't want to handle spawning threads or only want threads for short-lived
tasks, [Rayon](https://github.com/rayon-rs/rayon) is the perfect library!

```rust
fn double(values: &mut [i32]) {
    values.iter_mut().for_each(|i| *i *= 2);
}
```

With it, we can _easily_ make the above code use all available cores:

```rust
extern crate rayon;

use rayon::prelude::*;

fn par_double(values: &mut [i32]) {
    values.par_iter_mut().for_each(|i| *i *= 2);
}
```

Notice that it gracefully handles mutability of each element in `values`.

**Tip:** depending on input size, `double()` can outperform `par_double()` due
to factors like rayon's bookkeeping overhead. Benchmark accordingly!
]

---

.left-column[
## Multithreading
## SIMD
]

.right-column[
Rust can emit Single Instruction, Multiple Data
([SIMD](https://en.wikipedia.org/wiki/SIMD)) operations automagically via
[auto-vectorization](https://en.wikipedia.org/wiki/Automatic_vectorization):

```rust
// LLVM knows how to load, add, and write
// multiple values simultaneously
pub fn sum(a: &[u8], b: &[u8], c: &mut [u8]) {
    for ((a, b), c) in a.iter().zip(b).zip(c) {
        *c = *a + *b;
    }
}
```

See generated assembly @ [godbolt.org/z/51Qx5U](https://godbolt.org/z/51Qx5U)

Or we can explicitly use these instructions in a cross-platform way
(`sse`/`avx` on x86, `neon` on AArch64):

```rust
extern crate packed_simd;

use packed_simd::i32x4;

let a = i32x4::new(1, 2, 3, 4);
let b = i32x4::new(5, 6, 7, 8);
assert_eq!(a + b, i32x4::new(6, 8, 10, 12));
```
]

---

class: center, middle, inverse

<img src="img/wasm-ferris.png" width="40%">

# Intro to WebAssembly

_targeting the modern web at high speeds_

---

<h1 align="center">Learning Resources</h1>

## [Rust by Example](https://rustbyexample.com/)

A collection of runnable examples that illustrate various Rust concepts and
standard libraries.

## [Rust Book](https://doc.rust-lang.org/book/second-edition/) (2nd Edition)

An official introductory book on Rust.

## [Rust WASM Book](https://rustwasm.github.io/book/)

An official introductory book on targeting WebAssembly with Rust.

---

class: center, middle, inverse

<img src="img/qa-ferris.png" width="50%">

# Q & A

[rust]:   https://github.com/rust-lang/rust/
[play]:   https://play.rust-lang.org/
[rustup]: https://www.rustup.rs/

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightStyle: 'atom-one-dark',
        highlightLines: true,
        slideNumberFormat: (current, total) => `
          <div class="progress-bar-container">
            <div class="progress-bar" style="width: ${current/total*100}%">
            </div>
          </div>
        `,
      });
    </script>
  </body>
</html>
